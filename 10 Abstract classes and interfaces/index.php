<?php 
/*
урок №10 Абстрактные классы и интерфейсы.

Абстрактный класс существует для того чтобы исключить возможность создавать экземпляры класса. То есть я придумал что у меня есть общий класс Product от которого наследуются два моих класса BookProduct и LaptopProduct - то соответственно по моей логике, я юзаю родительский класс только как заготовку и хочу запретить создавать экземпляры от него (чтобы не путаться например). Тогда я его делаю абстрактным. 

Пример: есть класс Product и у него есть дочерний класс BookProduct. Если мы создадим экземпляр класса Product $product = new Product('Test', 100) - то он как раз и будет являться не нужным(абстрактным) экземпляром класса, т.к. у него нет всех нужных свойств. И для того чтобы исключить возможность создавать такие обстрактные экземпляры класса существуют специальные абстрактные классы. Создаются с помощью слова abstract перед названием класса. 

Мы просто не можем создать экземпляр абстрактного класса $product = new Product('Test', 1); - выдаст ошибку Cannot instantiate abstract class Product in ... Создавая абстрактный класс я как бы даю понять что не хочу чтобы создавались объекты этого класса. Дочерние классы работают без изменений.

Абстрактные классы появились с php 5. 

Методы класса тоже могут быть абстрактными. Если в классе есть хоть один абстрактный метод, то такой класс должен быть абстрактным.
Абстрактный метод должен быть пустым - без тела в {} - он создан для того чтобы от него наследовались - см в emma-oop например abstract public function name(): string; В дочернем классе обязательно нужно реализовать абстрактный метод родителя.

При наследовании от абстрактного класса все методы которые помечены абстрактными в родительском классе должны быть обязательно определены в дочернем классе. Количество параметров должно совпадать, но в дочернем можно добавить еще параметры с начальным значением (см пример в дочернем классе)

В чем преимущетсво: (честно говоря я не вдуплил)
Если мы работаем в команде, или один, но приложение большое - пишешь по частям и забываешь что писал в старых частях, используя абстрактный класс и абстрактные методы мы как бы получаем тех задание на реаличацию чего то.


************************************************* Интерфейсы *********************************************

Достаточно сложная тема и ее не понимают даже матерые оопшники бывает. Матроскин ни разу не юзал в своей практике интерфейсы (probably мне они не упали тоже их учить) и часто встречал код в котором интерфейсы абсолютно лишние - то есть люди не понимают зачем их юзают) Используют их для того чтоб использовать).

Интерфейсы - это те же самые классы, но без реализации. Объявляются как обычные классы, но вместо слова class используется слово interface. Плюс интерфейсов - что их можно наследовать сколь угодно много. Все методы которые мы объявляем в интерфейсе должны быть public и не должны имень реализацию(тело метода в {}) - это будет в дочернем интерфейсе. От интерфейса нельзя создать объект.

Интерфейсы создаются в отдельной папке (мы просто для теста создаем в папке classes) и как правило именуют начиная с I или i

Все методы интерфейса должны быть реализованы в классе (дочернем) реализующим данный интерфейс.

*/

error_reporting(-1);

require_once 'classes/Product.php';
require_once 'classes/I3d.php';
require_once 'classes/BookProduct.php';

$book = new BookProduct('Brave new world', 170, '200 страниц');

echo '<pre>';
print_r($book);
echo '</pre>';

echo $book->getProduct();
$book->addProduct('test', 175, 333);

$book->test();